네트워크 프로그래밍이란, 멀리 떨어져있는 호스트들이 서로 데이터를 주고 받을 수 있도록 프로그램을 구현하는 것
다만 파일과 달리 데이터를 주고 받을 대상이 멀리 떨어져있기 때문에 소프트웨어 차원에서 호스트간에 연결해주는 장치가 필요한데
그 장치가 소켓(socket)이다.
예를 들어 전화를 할때 우리는 매개체인 전화기가 필요하다. 
전화기 역할을 해주는 것이 socket이라고 볼 수 있다.

IP계층에서 IP가 붙고, 물리계층에서 MAC 주소등이 붙어서 나가는데 그것이 결국은 네트워크 카드로 간 후에 통신한다


1.소켓을 생성하는 함수: socket
#include <sys/socket.h>
#include <sys/types.h>

int socket(int domain,int type,int protocol)

int 형으로 함수 반환
호출 성공시 파일 디스트럽터 반환, 실패시 -1 반환
domain : 생성할 소켓이 통신을 하기 위해 사용할 프로토콜 체계를 설정
type : 소켓이 데이터를 전송하는데 있어서 ,사용하게 되는 전송타입 설정
protocol:두 호스트간의 통신에 있어서 특정 프로토콜을 지정



(1)domain에 들어가는 프로토콜 체계 (소켓을 사용할 영역)
=>
AF_INET = IPv4인터넷 프로토콜 = PF_INET
AF_INET6 = IPv6 인터넷 프로토콜 = PF_INET6
AF_LOCAL = Local 통신을 하기위한 UNIX프로토콜
AF_PACKET = Low level socket을 위한 인터페이스
AF_IPX = IPX노벨 프로토콜
ex ) AF_INET 을 소켓의 첫 번째 인자로 전달할 경우에는 소켓은 주소체계 IPv4를 기반으로 하는
인터넷 프로토콜에 적합한 소켓이 생성될 것이다.

(2) 소켓의 type
프로토콜을 정했다고 데이터 전송 타입까지 지정해준 것은 아니다.
즉 하나의 프로토콜 안에서도 데이터를 전송하는 방법이 둘 이상 존재할 수 있다.

대표적인 데이터 전송 방식 두가지
=>
SOCK_STREAM = 연결 지향형 소켓 방식 <-->IPPROTO_TCP 
-> 에러나 데이터의 손실없이 무사히 전달된다.
-> 전송하는 순서대로 데이터가 전달된다.
-> 한마디로 신뢰성 있는 순차적인 바이트 기반의 연결 지향 전송 타입 이라고 할 수 있다.
-> 데이터 크기에 제한이 없다.
SOCK_DGRAM = 비연결 지향형 소켓 방식
-> 전송되는 순서에 상관없이 가장 빠른 전송을 지향한다.
-> 전송되는 데이터는 손실될 수도 있고 에러가 발생할 수도 있다.
-> 한번에 전송되는 데이터 크기가 제한된다

(3) 소켓의 protocol <-->IPPROTO_UDP
이 인자는 호스트 대 호스트가 사용할 프로토콜을 설정하기 위해 사용된다.
프로토콜 체계(첫번째인자) 가 PF_INET일 경우 
다음과 같이 두가지가 올 수 있다.
IPPROTO_TCP : TCP기반 소켓생성
IPPROTO_UDP : UDP기반 소켓생성
사실 첫번째 두번째 인자만으로 연결지향형 소켓 , 비연결지향형 소켓을 만드는데 충분한 정보가 된다.
하지만 세번째 인자 프로토콜은 프로토콜을 조금더 구체화하기위해 사용된다. 
------------------------------------------------------------------
그렇다면 전화를 하기 위해 자신의 전화번호를 알 필요가 있다.
소켓도 마찬가지이다. 전화기에 전화번호를 할당하듯이 소켓에도 전화번호에 해당하는 소켓의 IP주소를 할당한다.

2.소켓에 IP주소를 할당하는 함수: bind
#include <sys/socket.h>

int bind(int sockfd,struct *myaddr,int addlen)

=>성공시 0을 리턴하고 실패시 -1을 리턴한다.
------------------------------------------------------------------
자 , 이제 전화번호까지 무사히 받았다. 이게 끝이아니다. 케이블이 전화에 연결되어있지않으면 아무 소용도 없다.
전화를 받을 수 있는 상황이라는 것은, 누군가 전화를 걸어서 연결 요청을 할수 있다는 뜻이다.
이와 마찬가지로 소켓도 이러한 상태가 되어야한다.

3.소켓을 연결 요청 가능한 상태로 되게하는 함수: listen
#include <sys/socket.h>

int listen(int sockfd, int backlog)
성공시 0, 실패시 -1 리턴
------------------------------------------------------------------
드디어 전화벨이 울린다!
이제 전화 요청을 받기 위해 수화기를 들어야한다 .소켓도 마찬가지로 누군가 데이터를 주고받기위해 요청을 했을때 그 요청을
수락할 수 있어야한다.

4. 요청을 수락하는 함수 : accept
#include <sys/socket.h>

int accept(int sockfd,struct sockaddr *myaddr, int *addrlen)
성공시 파일 디스트럽터 ,실패시 -1 리턴
------------------------------------------------------------------
내용을 정리하자면 , 전화기를 한대 구입하고,전화번호를 할당하고, 케이블에 연결하고, 전화 오기를 기다리다가 
전화가 오면 승낙해서 대화를 하는것이다.

이는 소켓이 소켓을 만들고, IP주소를 할당하고, 네트워크에 소켓을 연결하고, 요청이 오길 기다렸다가 요청이 오면 수락하여
통신을 하는 것을 의미한다.

이는 서버의 통신방법이다. 서버는 일반적으로 들어오는 요청을 받을 뿐 , 먼저 요청을 걸지 않는다
클라이언트에서 서버로 전화를 거는 기능의 함수는 

5)서버에게 요청하는 함수 :connect
#include <sys/socket.h>
#include <sys/types.h>

int connect(int sockfd, struct *serv_addr ,int addlen);
성공시 0, 실패시 -1 리턴


------------------------------------------------------------------
클라이언트 프로그램 구현순서

1.서버에 접속하기 위해 소켓을 생성한다.
2. connect 함수의 호출을 통해 서버로의 접속을 시도한다.
3. 연결이 완료되면 데이터를 주고 받는다.





-0 값으로 초기화 하기
memset (a,0,12);

먼저 a라는 매개변수는 값을 지정하수 있는 배열의 첫번째 주소입니다. 배열 이름을 입력해도 되겠지요.

0, 즉 콤마다음 두번째 매개변수는 채우고 싶은 값을 의미합니다.

12, 마지막 매개변수 12는 초기화하는 바이트를 의미합니다. int가 4바이트이고 a가 3개의 배열을 가진것이니까 4*3=12;가 되는 것이죠. malloc( ) 포스팅처럼 4*3 으로 표시해도 됩니다.






http://byneonkid.tistory.com/116 참고자료
http://jkkang.net/unix/netprg/chap2/net2_intro.html


포트번호 2바이트
ip주소 4바이트


