우선 채팅서버가 소켓을 만들고, 포트와 아이피와 함께 그 구조체를 bind 한다( 묶어둔다.)
*) 왜냐하면 클라이언트가 아이피를 통해 들어왔을 때 해당 포트로 연결해줘야하기 때문.


그 다음 연결을 기다리는 listen 상태로 간다.

MAX_CLIENT 값은 10 으로 주었고, 

새로운 배열(list_c[])을 하나 만들어서 우선 -1로 초기화한다. 왜냐하면 어디서 리퀘스트가 들어왔는지
for문을 돌면서 확인해야하므로 양수값을 집어넣으면 안된다. 함수가 성공적으로 호출된후 들어가는 값이
양수이기때문

그다음 예를 들어 client(A)란놈이 connect() 요청을 하면 채팅서버는 그 요청을 처리할 새로운 소켓하나를 생성한다. 이를 while(1)로 무한루프를 돌려 새로운 클라이언트의 connect()가 들어올 때마다 쓰레드를 하나씩 생성한다.
최대 10개까지 가능하다.
쓰레드를 만들면서 클라이언트로 부터 받은 c_socket을 인자로 전달하면서 do_chat 함수를 호출한다.

do_chat 함수는 전달받은 c_socket의 데이터를 chatData에 넣고 그 사이즈만큼 읽어온다.
읽어오는 것을 성공했으면 list_c[]를 INVALID_SOCK(-1)과 비교하면서 -1이 아니면 Client가 push 되어있다는 뜻이므로 전달받은 chatData를 다른 Client 들에게 보낸다.

그리고 무한루프를 계속 돌면서 strstr(chatData,escape("exit")) != NULL ==>문자열을 비교해서 인덱스값을 리턴하는 함수, 만약 값이없으면 NULL 값 반환. 즉, exit 라는 문자열을 만나면 c_socket을 popclient()의 인자로 보낸다. list_c에서 뺀다.



popclient()는 for문을 돌면서 그 소켓의 파일디스크럽터값(정수값) 을 list_c[]와 하나하나 비교하며
같은 값을 찾는다. 같은 값을 찾게되면 그 자리에 초기에 초기화 했던 정수 -1을 넣는다. 여기서 list_c[]는 전역변수이므로 임계영역(mutex lock) 하여 다른 스레드가 쓸수없도록 만든 후 실행한다.


